### For Demo Purposes Only ###
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'CloudFormation template to create resources for Bedrock Agents including OpenSearch serverless and Knowledge Base - For Demo Purposes Only'

Resources:
  TicketsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub ${AWS::StackName}-ITSM-Tickets
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: ticketNumber
          AttributeType: S
      KeySchema:
        - AttributeName: ticketNumber
          KeyType: HASH
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: alias/aws/dynamodb

  S3BucketBKB:
    Type: AWS::S3::Bucket
    Properties:
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  BedrockKnowledgeBaseRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-BedrockKnowledgeBaseRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AmazonBedrockKnowledgeBaseTrustPolicy
            Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-BedrockKnowledgeBasePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: VisualEditor0
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !GetAtt S3BucketBKB.Arn
                  - !Sub "${S3BucketBKB.Arn}/*"
              - Sid: VisualEditor1
                Effect: Allow
                Action: bedrock:InvokeModel
                Resource: '*'

                
  BedrockAgentRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-BedrockAgentRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AmazonBedrockAgentBedrockFoundationModelPolicyProd
            Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-BedrockAgentPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: VisualEditor0
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:Retrieve
                  - bedrock:RetrieveAndGenerate
                Resource:
                  - !Sub arn:aws:bedrock:*::foundation-model/*
                  - !Sub arn:aws:bedrock:*:${AWS::AccountId}:inference-profile/*
                  - !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*
              - Sid: VisualEditor1
                Effect: Allow
                Action: 
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt BedrockAgentLambdaCreateITSM.Arn
                  - !GetAtt BedrockAgentLambdaLookupITSM.Arn
              - Sid: VisualEditor2
                Effect: Allow
                Action:
                  - bedrock:CreateAgent
                  - bedrock:UpdateAgent
                Resource: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'
              - Sid: VisualEditor3
                Effect: Allow
                Action:
                  - bedrock:GetInferenceProfile
                  - bedrock:ListInferenceProfiles
                  - bedrock:ListModels
                  - bedrock:GetModel
                Resource: '*'

  ITSMLambdaFunctionCreate:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-ITSM-Create
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRoleCreate.Arn
      Runtime: nodejs22.x
      Environment:
        Variables:
          TABLE_NAME: !Ref TicketsTable
      CodeUri: functions/create-itsm/
          
  ITSMLambdaFunctionLookup:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-ITSM-Lookup
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRoleLookup.Arn
      Runtime: nodejs22.x
      Environment:
        Variables:
          TABLE_NAME: !Ref TicketsTable
      CodeUri: functions/lookup-itsm/

  LambdaExecutionRoleCreate:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt TicketsTable.Arn
        - PolicyName: !Sub ${AWS::StackName}-APIGatewayInvokePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:Invoke
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:*/*'

  LambdaExecutionRoleLookup:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                Resource: !GetAtt TicketsTable.Arn
        - PolicyName: !Sub ${AWS::StackName}-APIGatewayInvokePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:Invoke
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:*/*'

  BedrockAgentLambdaCreateITSM:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-BedrockAgent-CreateITSM-Function
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRoleCreate.Arn
      Runtime: python3.12
      Environment:
        Variables:
          API: !Sub https://${ApiGatewayITSM}.execute-api.${AWS::Region}.amazonaws.com/prd
      CodeUri: functions/create-itsm-api/
                  
  BedrockAgentLambdaLookupITSM:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-BedrockAgent-LookupITSM-Function
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRoleLookup.Arn
      Runtime: python3.12
      Environment:
        Variables:
          API: !Sub https://${ApiGatewayITSM}.execute-api.${AWS::Region}.amazonaws.com/prd
      CodeUri: functions/lookup-itsm-api/

  # OpenSearch Serverless Collection
  OpenSearchCollection:
    Type: AWS::OpenSearchServerless::Collection
    DependsOn:
      - OpenSearchNetworkPolicy
      - OpenSearchAccessPolicy
      - OpenSearchEncryptionPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-kb-collection
      Type: VECTORSEARCH
      Description: Collection for Bedrock Knowledge Base
      StandbyReplicas: DISABLED

  # OpenSearch Serverless Network Policy
  OpenSearchNetworkPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-kb-np
      Type: network
      Description: Network policy for OpenSearch Serverless collection
      Policy: !Sub |
        [{
          "Rules": [
            {
              "ResourceType": "dashboard",
              "Resource": ["collection/${AWS::StackName}-kb-collection"]
            },
            {
              "ResourceType": "collection",
              "Resource": ["collection/${AWS::StackName}-kb-collection"]
            }
          ],
          "AllowFromPublic": true
        }]

  # OpenSearch Serverless Security Policy (Data Access)
  OpenSearchAccessPolicy:
    Type: AWS::OpenSearchServerless::AccessPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-kb-ap
      Type: data
      Description: Access policy for Bedrock Knowledge Base collection
      Policy: !Sub |
        [{
          "Rules": [
            {
              "ResourceType": "collection",
              "Resource": ["collection/${AWS::StackName}-kb-collection"],
              "Permission": [
                "aoss:DescribeCollectionItems",
                "aoss:CreateCollectionItems",
                "aoss:UpdateCollectionItems"
              ]
            },
            {
              "ResourceType": "index",
              "Resource": ["index/${AWS::StackName}-kb-collection/*"],
              "Permission": [
                "aoss:UpdateIndex",
                "aoss:DescribeIndex",
                "aoss:ReadDocument",
                "aoss:WriteDocument",
                "aoss:CreateIndex"
              ]
            }
          ],
          "Principal": [
            "${BedrockKnowledgeBaseRole.Arn}",
            "${OpenSearchIndexCreatorRole.Arn}"
          ],
          "Description": "Access policy for Bedrock Knowledge Base"
        }]

  # OpenSearch Serverless Encryption Policy
  OpenSearchEncryptionPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-kb-ep
      Type: encryption
      Description: Encryption policy for OpenSearch Serverless collection
      Policy: !Sub |
        {
          "Rules": [
            {
              "ResourceType": "collection",
              "Resource": ["collection/${AWS::StackName}-kb-collection"]
            }
          ],
          "AWSOwnedKey": true
        }

  # Lambda role for OpenSearch index creation
  OpenSearchIndexCreatorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # Lambda function to create OpenSearch index
  OpenSearchIndexCreatorFunction:
    Type: AWS::Lambda::Function
    DependsOn: OpenSearchIndexCreatorPolicy
    Properties:
      Handler: index.handler
      Role: !GetAtt OpenSearchIndexCreatorRole.Arn
      Runtime: python3.12
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import cfnresponse
          import logging
          import time
          import urllib3
          import hashlib
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest
          from botocore.session import get_session

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          http = urllib3.PoolManager()

          def handler(event, context):
              logger.info('Received event: %s', json.dumps(event))
              
              response_data = {}
              
              try:
                  request_type = event['RequestType']
                  
                  if request_type == 'Create' or request_type == 'Update':
                      collection_endpoint = event['ResourceProperties']['CollectionEndpoint']
                      index_name = event['ResourceProperties'].get('IndexName', '!Sub ${AWS::StackName}-kb-collection')
                      
                      create_index(collection_endpoint, index_name)
                      response_data['Message'] = f"Successfully created index {index_name}"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
                  elif request_type == 'Delete':
                      response_data['Message'] = "Index will be deleted with the collection"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
              
              except Exception as e:
                  logger.error('Error: %s', str(e))
                  response_data['Error'] = str(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

          def create_index(collection_endpoint, index_name):
              index_mapping = {
                  "settings": {
                      "index": {
                          "knn": "true"
                      }
                  },
                  "mappings": {
                      "dynamic_templates": [
                          {
                              "strings": {
                                  "match_mapping_type": "string",
                                  "mapping": {
                                      "fields": {
                                          "keyword": {
                                              "ignore_above": 2147483647,
                                              "type": "keyword"
                                          }
                                      },
                                      "type": "text"
                                  }
                              }
                          }
                      ],
                      "properties": {
                          "bedrock-knowledge-base-default-vector": {
                              "type": "knn_vector",
                              "dimension": 1024,
                              "method": {
                                  "engine": "faiss",
                                  "space_type": "l2",
                                  "name": "hnsw",
                                  "parameters": {}
                              }
                          },
                          "AMAZON_BEDROCK_METADATA": {
                              "type": "text",
                              "index": "false"
                          },
                          "AMAZON_BEDROCK_TEXT_CHUNK": {
                              "type": "text",
                              "index": "true"
                          }
                      }
                  }
              }
              
              if not collection_endpoint.startswith('https://'):
                  collection_endpoint = f"https://{collection_endpoint}"
              
              url = f"{collection_endpoint}/{index_name}"
              body = json.dumps(index_mapping).encode("utf-8")
              sha256_hash = hashlib.sha256(body).hexdigest()

              session = boto3.Session()
              credentials = session.get_credentials().get_frozen_credentials()
              region = session.region_name or os.environ.get("AWS_REGION", "us-east-1")

              headers = {
                  "Content-Type": "application/json",
                  "Host": collection_endpoint.replace("https://", ""),
                  "x-amz-content-sha256": sha256_hash
              }

              # Sign the request
              request = AWSRequest(method="PUT", url=url, data=body, headers=headers)
              SigV4Auth(credentials, "aoss", region).add_auth(request)
              signed_headers = dict(request.headers)

              try:
                  response = http.request("PUT", url, body=body, headers=signed_headers)

                  time.sleep(60)

                  if 200 <= response.status < 300:
                      logger.info(f"Successfully created index {index_name}: {response.data.decode('utf-8')}")
                  else:
                      logger.error(f"Failed to create index: {response.status} - {response.data.decode('utf-8')}")
                      raise Exception(f"Failed to create index: {response.status} - {response.data.decode('utf-8')}")
              
              except Exception as e:
                  logger.error(f"Error creating index: {str(e)}")
                  raise

  # Custom resource to create the OpenSearch index
  OpenSearchIndexCreator:
    Type: Custom::OpenSearchIndexCreator
    DependsOn: OpenSearchCollection
    Properties:
      ServiceToken: !GetAtt OpenSearchIndexCreatorFunction.Arn
      CollectionEndpoint: !GetAtt OpenSearchCollection.CollectionEndpoint
      IndexName: !Sub ${AWS::StackName}-kb-collection

  # Separate IAM Policy for OpenSearch access to break circular dependency
  BedrockKnowledgeBaseOpenSearchPolicy:
    Type: AWS::IAM::Policy
    DependsOn: OpenSearchCollection
    Properties:
      PolicyName: !Sub ${AWS::StackName}-BedrockKnowledgeBaseOpenSearchPolicy
      Roles:
        - !Ref BedrockKnowledgeBaseRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action: aoss:APIAccessAll
            Resource: !GetAtt OpenSearchCollection.Arn

  # Separate IAM Policy for OpenSearchIndexCreatorRole to break circular dependency
  OpenSearchIndexCreatorPolicy:
    Type: AWS::IAM::Policy
    DependsOn: OpenSearchCollection
    Properties:
      PolicyName: !Sub ${AWS::StackName}-OpenSearchIndexCreatorPolicy
      Roles:
        - !Ref OpenSearchIndexCreatorRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - aoss:APIAccessAll
            Resource: 
              - !GetAtt OpenSearchCollection.Arn
              - !Sub '${OpenSearchCollection.Arn}/*'

 # IAM Role for Bedrock Entitlement Lambda
  BedrockEntitlementRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-BedrockEntitlementAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:PutFoundationModelEntitlement
                Resource: '*'

  # Lambda function for Bedrock model entitlement
  BedrockEntitlementFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt BedrockEntitlementRole.Arn
      Runtime: python3.12
      Timeout: 60
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import hashlib
          import urllib3
          import cfnresponse
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest
          from botocore.session import get_session

          http = urllib3.PoolManager()

          def lambda_handler(event, context):
              session = boto3.Session()
              credentials = session.get_credentials().get_frozen_credentials()
              region = session.region_name or os.environ.get("AWS_REGION", "us-east-1")
              response_data = {}
              
              request_type = event['RequestType']

              try:
                  if request_type == 'Create' or request_type == 'Update':
                      # API endpoint
                      url = f"https://bedrock.{region}.amazonaws.com/foundation-model-entitlement"
                      
                      # Headers to be signed
                      headers = {
                          'Content-Type': 'application/json',
                          'Accept': '*/*',
                          'Host': f"bedrock.{region}.amazonaws.com"
                      }

                      model_ids = [
                          event['ResourceProperties'].get('ModelId1'),
                          event['ResourceProperties'].get('ModelId2')
                      ]

                      for model_id in model_ids:
                          if not model_id:
                              continue
                          
                          payload_dict = {"modelId": model_id}
                          body = json.dumps(payload_dict).encode("utf-8")
                          sha256_hash = hashlib.sha256(body).hexdigest()
                          headers['x-amz-content-sha256'] = sha256_hash

                          request = AWSRequest(method="POST", url=url, data=body, headers=headers)
                          SigV4Auth(credentials, "bedrock", region).add_auth(request)
                          signed_headers = dict(request.headers)

                          response = http.request("POST", url, body=body, headers=signed_headers)

                          response_data[f'StatusCode_{model_id}'] = response.status
                          if response.status >= 400:
                              raise Exception(f"Entitlement request for {model_id} failed: {response.status} - {response.data.decode('utf-8')}")

                      response_data['Message'] = "Model entitlement request processed"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

                  elif request_type == 'Delete':
                      response_data['Message'] = "No action required for Delete"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

              except Exception as e:
                  response_data['Error'] = str(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

  # Custom resource for Bedrock model entitlement
  BedrockModelEntitlement:
    Type: Custom::BedrockModelEntitlement
    Properties:
      ServiceToken: !GetAtt BedrockEntitlementFunction.Arn
      ModelId1: amazon.nova-lite-v1:0
      ModelId2: amazon.titan-embed-text-v2:0

  # Bedrock Knowledge Base
  BedrockKnowledgeBase:
    Type: AWS::Bedrock::KnowledgeBase
    DependsOn: 
      - OpenSearchIndexCreator
      - BedrockKnowledgeBaseOpenSearchPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-agent-kb
      Description: Knowledge Base for Bedrock Agent
      RoleArn: !GetAtt BedrockKnowledgeBaseRole.Arn
      KnowledgeBaseConfiguration:
        Type: VECTOR
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub arn:aws:bedrock:${AWS::Region}::foundation-model/amazon.titan-embed-text-v2:0
      StorageConfiguration:
        Type: OPENSEARCH_SERVERLESS
        OpensearchServerlessConfiguration:
          CollectionArn: !GetAtt OpenSearchCollection.Arn
          VectorIndexName: !Sub ${AWS::StackName}-kb-collection
          FieldMapping:
            VectorField: bedrock-knowledge-base-default-vector
            TextField: AMAZON_BEDROCK_TEXT_CHUNK
            MetadataField: AMAZON_BEDROCK_METADATA

  # Bedrock Data Source
  BedrockDataSource:
    Type: AWS::Bedrock::DataSource
    DependsOn: BedrockKnowledgeBase
    Properties:
      Name: !Sub ${AWS::StackName}-agent-kb-datasource
      Description: Data Source for Bedrock Agent
      KnowledgeBaseId: !GetAtt BedrockKnowledgeBase.KnowledgeBaseId
      DataSourceConfiguration:
        Type: S3
        S3Configuration:
          BucketArn: !GetAtt S3BucketBKB.Arn

  # Bedrock Agent
  BedrockAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: !Sub ${AWS::StackName}-bedrock-agent
      AgentResourceRoleArn: !GetAtt BedrockAgentRole.Arn
      Description: Agent that uses knowledge base and ITSM ticket creation API
      Instruction: You are a helpful assistant that can answer questions about the IT Employee handbook using the knowledge base. You can also create new ITSM tickets using the /create API endpoint or look up ITSM ticket using the /lookup API. When an action group creates a ticket, pass the ticket number you received back to the user. When a user asks you to look up the status, description, urgency, impact, or created date of a ticket number, use the /lookup API. Do not make up any details for the ticket, the details must come from the lookup tool.  Provide all details the user asks for from the lookup tool response.
      FoundationModel: us.amazon.nova-lite-v1:0
      IdleSessionTTLInSeconds: 1800
      KnowledgeBases:
        - KnowledgeBaseId: !GetAtt BedrockKnowledgeBase.KnowledgeBaseId
          Description: IT Employee Handbook knowledge base
      ActionGroups:
        - ActionGroupName: UserInputAction
          ActionGroupState: ENABLED
          ParentActionGroupSignature: AMAZON.UserInput
        - ActionGroupName: TicketCreationAPI
          ActionGroupExecutor:
            Lambda: !GetAtt BedrockAgentLambdaCreateITSM.Arn
          Description: Action group for ticket creation API
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "ITSM Ticket Management API",
                  "version": "1.0.0",
                  "description": "APIs for managing ITSM tickets"
                },
                "paths": {
                  "/create": {
                    "post": {
                      "summary": "API to create an ITSM ticket",
                      "description": "Create an ITSM ticket by passing in 4 parameters in the json body: tickettype, description, impact, and urgency.",
                      "operationId": "createTicket",
                      "requestBody": {
                        "required": "true",
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "tickettype": {
                                  "type": "string",
                                  "description": "type of ticket to create, example INC0001, CHG0001, etc."
                                },
                                "description": {
                                  "type": "string",
                                  "description": "description of the issue or request"
                                },
                                "impact": {
                                  "type": "string",
                                  "description": "Impact of the issue or request"
                                },
                                "urgency": {
                                  "type": "string",
                                  "description": "urgency of the request"
                                }
                              },
                              "required": [
                                "tickettype",
                                "description",
                                "impact",
                                "urgency"
                              ]
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Ticket created successfully",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "ticketNumber": {
                                    "type": "string",
                                    "description": "Response from ITSM with ticket number"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "400": {
                          "description": "Bad request. One or more required fields are missing or invalid."
                        }
                      }
                    }
                  }
                }
              }
        - ActionGroupName: TicketLookupAPI
          ActionGroupExecutor:
            Lambda: !GetAtt BedrockAgentLambdaLookupITSM.Arn
          Description: Action group for ticket lookup API
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "ITSM Ticket Management API",
                  "version": "1.0.0",
                  "description": "APIs for managing ITSM tickets"
                },
                "paths": {
                  "/lookup": {
                    "get": {
                      "summary": "API to lookup the status and information for an ITSM ticket number",
                      "description": "Lookup the status and information for an ITSM ticket by passing in 1 parameter in the json body: ticketNumber",
                      "operationId": "lookupTicket",
                      "requestBody": {
                        "required": "true",
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "ticketNumber": {
                                  "type": "string",
                                  "description": "the ticket number provided by the user"
                                }
                              },
                              "required": [
                                "ticketNumber"
                              ]
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Status and details of the ticket number lookup",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "ticketStatus": {
                                    "type": "string",
                                    "description": "Status of the ticket"
                                  },
                                  "ticketDesc": {
                                    "type": "string",
                                    "description": "Description or details of the ticket"
                                  },
                                  "ticketImpact": {
                                    "type": "string",
                                    "description": "Impact of the ticket"
                                  },
                                  "ticketUrgency": {
                                    "type": "string",
                                    "description": "Urgency of the ticket"
                                  },
                                  "createdAt": {
                                    "type": "string",
                                    "description": "Date the ticket was created"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "400": {
                          "description": "Bad request. One or more required fields are missing or invalid."
                        }
                      }
                    }
                  }
                }
              }

  # Create Agent Alias
  BedrockAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    DependsOn: BedrockAgent
    Properties:
      AgentId: !Ref BedrockAgent
      AgentAliasName: DRAFT
      Description: Alias for the bedrock agent
      RoutingConfiguration: []

  LambdaCreatePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ITSMLambdaFunctionCreate
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayITSM}/*/POST/create
      
  LambdaLookupPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ITSMLambdaFunctionLookup
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayITSM}/*/GET/lookup
      
  BedrockAgentLambdaCreateITSMPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref BedrockAgentLambdaCreateITSM
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*

  BedrockAgentLambdaLookupITSMPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref BedrockAgentLambdaLookupITSM
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*

  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: ApiGatewayITSM
    Properties:
      RestApiId: !Ref ApiGatewayITSM
      StageName: prd

  ApiGatewayITSM:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub ${AWS::StackName}-itsm-api
      Description: Sample ITSM API
      Body:
        openapi: "3.0.1"
        info:
          title: "itsm-api"
          description: "Sample ITSM API"
          version: "2025-05-30T16:52:31Z"
        paths:
          /create:
            post:
              x-amazon-apigateway-auth:
                type: "AWS_IAM"
              responses:
                "200":
                  description: "200 response"
                  content:
                    application/json:
                      schema:
                        $ref: "#/components/schemas/Empty"
              x-amazon-apigateway-integration:
                httpMethod: "POST"
                uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ITSMLambdaFunctionCreate.Arn}/invocations
                responses:
                  default:
                    statusCode: "200"
                requestTemplates:
                  application/json: |
                    #set($inputRoot = $input.path('$'))
                    {
                      "tickettype": "$inputRoot.tickettype",
                      "description": "$inputRoot.description",
                      "impact": "$inputRoot.impact",
                      "urgency": "$inputRoot.urgency"
                    }
                passthroughBehavior: "when_no_match"
                timeoutInMillis: 29000
                contentHandling: "CONVERT_TO_TEXT"
                type: "aws"
            options:
              responses:
                "200":
                  description: "200 response"
                  headers:
                    Access-Control-Allow-Origin:
                      schema:
                        type: "string"
                    Access-Control-Allow-Methods:
                      schema:
                        type: "string"
                    Access-Control-Allow-Headers:
                      schema:
                        type: "string"
                  content:
                    application/json:
                      schema:
                        $ref: "#/components/schemas/Empty"
              x-amazon-apigateway-integration:
                responses:
                  default:
                    statusCode: "200"
                    responseParameters:
                      method.response.header.Access-Control-Allow-Methods: "'DELETE,GET,HEAD,OPTIONS,PATCH,POST,PUT'"
                      method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token'"
                      method.response.header.Access-Control-Allow-Origin: "'*'"
                requestTemplates:
                  application/json: "{\"statusCode\": 200}"
                passthroughBehavior: "when_no_match"
                type: "mock"
          /lookup:
            get:
              x-amazon-apigateway-auth:
                type: "AWS_IAM"
              parameters:
                - name: ticketNumber
                  in: query
                  required: true
                  schema:
                    type: string
              responses:
                "200":
                  description: "200 response"
                  content:
                    application/json:
                      schema:
                        $ref: "#/components/schemas/Empty"
              x-amazon-apigateway-integration:
                httpMethod: "POST"
                uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ITSMLambdaFunctionLookup.Arn}/invocations
                responses:
                  default:
                    statusCode: "200"
                requestTemplates:
                  application/json: |
                    {
                      "ticketNumber": "$input.params('ticketNumber')"
                    }
                passthroughBehavior: "when_no_match"
                timeoutInMillis: 29000
                contentHandling: "CONVERT_TO_TEXT"
                type: "aws"
            options:
              responses:
                "200":
                  description: "200 response"
                  headers:
                    Access-Control-Allow-Origin:
                      schema:
                        type: "string"
                    Access-Control-Allow-Methods:
                      schema:
                        type: "string"
                    Access-Control-Allow-Headers:
                      schema:
                        type: "string"
                  content:
                    application/json:
                      schema:
                        $ref: "#/components/schemas/Empty"
              x-amazon-apigateway-integration:
                responses:
                  default:
                    statusCode: "200"
                    responseParameters:
                      method.response.header.Access-Control-Allow-Methods: "'DELETE,GET,HEAD,OPTIONS,PATCH,POST,PUT'"
                      method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token'"
                      method.response.header.Access-Control-Allow-Origin: "'*'"
                requestTemplates:
                  application/json: "{\"statusCode\": 200}"
                passthroughBehavior: "when_no_match"
                type: "mock"
        components:
          schemas:
            Empty:
              title: "Empty Schema"
              type: "object"

Outputs:
  S3BucketName:
    Description: S3 Bucket for Knowledge Base documents
    Value: !Ref S3BucketBKB
    
  BedrockAgentId:
    Description: Bedrock Agent ID
    Value: !Ref BedrockAgent
    Export:
      Name: "ITSMBedrockAgentId"
    
  BedrockAgentAliasId:
    Description: Bedrock Agent Alias ID
    Value: !GetAtt BedrockAgentAlias.AgentAliasId
    Export:
      Name: "ITSMBedrockAgentAliasId"

  KnowledgeBaseId:
    Description: Bedrock Knowledge Base ID
    Value: !GetAtt BedrockKnowledgeBase.KnowledgeBaseId