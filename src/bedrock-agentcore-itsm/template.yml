### For Demo Purposes Only ###
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'CloudFormation template to create resources for Bedrock AgentCore including OpenSearch serverless and Knowledge Base - For Demo Purposes Only'

Resources:
  # Shared Infrastructure Resources (copied from Bedrock Agents implementation)
  
  TicketsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub ${AWS::StackName}-ITSM-Tickets
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: ticketNumber
          AttributeType: S
      KeySchema:
        - AttributeName: ticketNumber
          KeyType: HASH
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: alias/aws/dynamodb

  S3BucketBKB:
    Type: AWS::S3::Bucket
    Properties:
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  # OpenSearch Serverless Collection
  OpenSearchCollection:
    Type: AWS::OpenSearchServerless::Collection
    DependsOn:
      - OpenSearchNetworkPolicy
      - OpenSearchAccessPolicy
      - OpenSearchEncryptionPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-kb-collection
      Type: VECTORSEARCH
      Description: Collection for Bedrock Knowledge Base
      StandbyReplicas: DISABLED

  # OpenSearch Serverless Network Policy
  OpenSearchNetworkPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-kb-np
      Type: network
      Description: Network policy for OpenSearch Serverless collection
      Policy: !Sub |
        [{
          "Rules": [
            {
              "ResourceType": "dashboard",
              "Resource": ["collection/${AWS::StackName}-kb-collection"]
            },
            {
              "ResourceType": "collection",
              "Resource": ["collection/${AWS::StackName}-kb-collection"]
            }
          ],
          "AllowFromPublic": true
        }]

  # OpenSearch Serverless Security Policy (Data Access)
  OpenSearchAccessPolicy:
    Type: AWS::OpenSearchServerless::AccessPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-kb-ap
      Type: data
      Description: Access policy for Bedrock Knowledge Base collection
      Policy: !Sub |
        [{
          "Rules": [
            {
              "ResourceType": "collection",
              "Resource": ["collection/${AWS::StackName}-kb-collection"],
              "Permission": [
                "aoss:DescribeCollectionItems",
                "aoss:CreateCollectionItems",
                "aoss:UpdateCollectionItems"
              ]
            },
            {
              "ResourceType": "index",
              "Resource": ["index/${AWS::StackName}-kb-collection/*"],
              "Permission": [
                "aoss:UpdateIndex",
                "aoss:DescribeIndex",
                "aoss:ReadDocument",
                "aoss:WriteDocument",
                "aoss:CreateIndex"
              ]
            }
          ],
          "Principal": [
            "${BedrockKnowledgeBaseRole.Arn}",
            "${OpenSearchIndexCreatorRole.Arn}"
          ],
          "Description": "Access policy for Bedrock Knowledge Base"
        }]

  # OpenSearch Serverless Encryption Policy
  OpenSearchEncryptionPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-kb-ep
      Type: encryption
      Description: Encryption policy for OpenSearch Serverless collection
      Policy: !Sub |
        {
          "Rules": [
            {
              "ResourceType": "collection",
              "Resource": ["collection/${AWS::StackName}-kb-collection"]
            }
          ],
          "AWSOwnedKey": true
        }

  # Lambda role for OpenSearch index creation
  OpenSearchIndexCreatorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # Lambda function to create OpenSearch index
  OpenSearchIndexCreatorFunction:
    Type: AWS::Lambda::Function
    DependsOn: OpenSearchIndexCreatorPolicy
    Properties:
      Handler: index.handler
      Role: !GetAtt OpenSearchIndexCreatorRole.Arn
      Runtime: python3.12
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import cfnresponse
          import logging
          import time
          import urllib3
          import hashlib
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest
          from botocore.session import get_session

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          http = urllib3.PoolManager()

          def handler(event, context):
              logger.info('Received event: %s', json.dumps(event))
              
              response_data = {}
              
              try:
                  request_type = event['RequestType']
                  
                  if request_type == 'Create' or request_type == 'Update':
                      collection_endpoint = event['ResourceProperties']['CollectionEndpoint']
                      index_name = event['ResourceProperties'].get('IndexName', '!Sub ${AWS::StackName}-kb-collection')
                      
                      create_index(collection_endpoint, index_name)
                      response_data['Message'] = f"Successfully created index {index_name}"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
                  elif request_type == 'Delete':
                      response_data['Message'] = "Index will be deleted with the collection"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
              
              except Exception as e:
                  logger.error('Error: %s', str(e))
                  response_data['Error'] = str(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

          def create_index(collection_endpoint, index_name):
              index_mapping = {
                  "settings": {
                      "index": {
                          "knn": "true"
                      }
                  },
                  "mappings": {
                      "dynamic_templates": [
                          {
                              "strings": {
                                  "match_mapping_type": "string",
                                  "mapping": {
                                      "fields": {
                                          "keyword": {
                                              "ignore_above": 2147483647,
                                              "type": "keyword"
                                          }
                                      },
                                      "type": "text"
                                  }
                              }
                          }
                      ],
                      "properties": {
                          "bedrock-knowledge-base-default-vector": {
                              "type": "knn_vector",
                              "dimension": 1024,
                              "method": {
                                  "engine": "faiss",
                                  "space_type": "l2",
                                  "name": "hnsw",
                                  "parameters": {}
                              }
                          },
                          "AMAZON_BEDROCK_METADATA": {
                              "type": "text",
                              "index": "false"
                          },
                          "AMAZON_BEDROCK_TEXT_CHUNK": {
                              "type": "text",
                              "index": "true"
                          }
                      }
                  }
              }
              
              if not collection_endpoint.startswith('https://'):
                  collection_endpoint = f"https://{collection_endpoint}"
              
              url = f"{collection_endpoint}/{index_name}"
              body = json.dumps(index_mapping).encode("utf-8")
              sha256_hash = hashlib.sha256(body).hexdigest()

              session = boto3.Session()
              credentials = session.get_credentials().get_frozen_credentials()
              region = session.region_name or os.environ.get("AWS_REGION", "us-east-1")

              headers = {
                  "Content-Type": "application/json",
                  "Host": collection_endpoint.replace("https://", ""),
                  "x-amz-content-sha256": sha256_hash
              }

              # Sign the request
              request = AWSRequest(method="PUT", url=url, data=body, headers=headers)
              SigV4Auth(credentials, "aoss", region).add_auth(request)
              signed_headers = dict(request.headers)

              try:
                  response = http.request("PUT", url, body=body, headers=signed_headers)

                  time.sleep(60)

                  if 200 <= response.status < 300:
                      logger.info(f"Successfully created index {index_name}: {response.data.decode('utf-8')}")
                  else:
                      logger.error(f"Failed to create index: {response.status} - {response.data.decode('utf-8')}")
                      raise Exception(f"Failed to create index: {response.status} - {response.data.decode('utf-8')}")
              
              except Exception as e:
                  logger.error(f"Error creating index: {str(e)}")
                  raise

  # Custom resource to create the OpenSearch index
  OpenSearchIndexCreator:
    Type: Custom::OpenSearchIndexCreator
    DependsOn: OpenSearchCollection
    Properties:
      ServiceToken: !GetAtt OpenSearchIndexCreatorFunction.Arn
      CollectionEndpoint: !GetAtt OpenSearchCollection.CollectionEndpoint
      IndexName: !Sub ${AWS::StackName}-kb-collection

  # Separate IAM Policy for OpenSearchIndexCreatorRole to break circular dependency
  OpenSearchIndexCreatorPolicy:
    Type: AWS::IAM::Policy
    DependsOn: OpenSearchCollection
    Properties:
      PolicyName: !Sub ${AWS::StackName}-OpenSearchIndexCreatorPolicy
      Roles:
        - !Ref OpenSearchIndexCreatorRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - aoss:APIAccessAll
            Resource: 
              - !GetAtt OpenSearchCollection.Arn
              - !Sub '${OpenSearchCollection.Arn}/*'

  # IAM Role for Bedrock Entitlement Lambda
  BedrockEntitlementRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-BedrockEntitlementAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:PutFoundationModelEntitlement
                Resource: '*'

  # Lambda function for Bedrock model entitlement
  BedrockEntitlementFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt BedrockEntitlementRole.Arn
      Runtime: python3.12
      Timeout: 60
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import hashlib
          import urllib3
          import cfnresponse
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest
          from botocore.session import get_session

          http = urllib3.PoolManager()

          def lambda_handler(event, context):
              session = boto3.Session()
              credentials = session.get_credentials().get_frozen_credentials()
              region = session.region_name or os.environ.get("AWS_REGION", "us-east-1")
              response_data = {}
              
              request_type = event['RequestType']

              try:
                  if request_type == 'Create' or request_type == 'Update':
                      # API endpoint
                      url = f"https://bedrock.{region}.amazonaws.com/foundation-model-entitlement"
                      
                      # Headers to be signed
                      headers = {
                          'Content-Type': 'application/json',
                          'Accept': '*/*',
                          'Host': f"bedrock.{region}.amazonaws.com"
                      }

                      model_ids = [
                          event['ResourceProperties'].get('ModelId1'),
                          event['ResourceProperties'].get('ModelId2')
                      ]

                      for model_id in model_ids:
                          if not model_id:
                              continue
                          
                          payload_dict = {"modelId": model_id}
                          body = json.dumps(payload_dict).encode("utf-8")
                          sha256_hash = hashlib.sha256(body).hexdigest()
                          headers['x-amz-content-sha256'] = sha256_hash

                          request = AWSRequest(method="POST", url=url, data=body, headers=headers)
                          SigV4Auth(credentials, "bedrock", region).add_auth(request)
                          signed_headers = dict(request.headers)

                          response = http.request("POST", url, body=body, headers=signed_headers)

                          response_data[f'StatusCode_{model_id}'] = response.status
                          if response.status >= 400:
                              raise Exception(f"Entitlement request for {model_id} failed: {response.status} - {response.data.decode('utf-8')}")

                      response_data['Message'] = "Model entitlement request processed"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

                  elif request_type == 'Delete':
                      response_data['Message'] = "No action required for Delete"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

              except Exception as e:
                  response_data['Error'] = str(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

  # Custom resource for Bedrock model entitlement
  BedrockModelEntitlement:
    Type: Custom::BedrockModelEntitlement
    Properties:
      ServiceToken: !GetAtt BedrockEntitlementFunction.Arn
      ModelId1: amazon.nova-lite-v1:0
      ModelId2: amazon.titan-embed-text-v2:0

  # Bedrock Knowledge Base Role
  BedrockKnowledgeBaseRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-BedrockKnowledgeBaseRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AmazonBedrockKnowledgeBaseTrustPolicy
            Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-BedrockKnowledgeBasePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: VisualEditor0
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !GetAtt S3BucketBKB.Arn
                  - !Sub "${S3BucketBKB.Arn}/*"
              - Sid: VisualEditor1
                Effect: Allow
                Action: bedrock:InvokeModel
                Resource: '*'

  # Separate IAM Policy for OpenSearch access to break circular dependency
  BedrockKnowledgeBaseOpenSearchPolicy:
    Type: AWS::IAM::Policy
    DependsOn: OpenSearchCollection
    Properties:
      PolicyName: !Sub ${AWS::StackName}-BedrockKnowledgeBaseOpenSearchPolicy
      Roles:
        - !Ref BedrockKnowledgeBaseRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action: aoss:APIAccessAll
            Resource: !GetAtt OpenSearchCollection.Arn

  # Bedrock Knowledge Base
  BedrockKnowledgeBase:
    Type: AWS::Bedrock::KnowledgeBase
    DependsOn: 
      - OpenSearchIndexCreator
      - BedrockKnowledgeBaseOpenSearchPolicy
    Properties:
      Name: !Sub ${AWS::StackName}-agent-kb
      Description: Knowledge Base for Bedrock AgentCore
      RoleArn: !GetAtt BedrockKnowledgeBaseRole.Arn
      KnowledgeBaseConfiguration:
        Type: VECTOR
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub arn:aws:bedrock:${AWS::Region}::foundation-model/amazon.titan-embed-text-v2:0
      StorageConfiguration:
        Type: OPENSEARCH_SERVERLESS
        OpensearchServerlessConfiguration:
          CollectionArn: !GetAtt OpenSearchCollection.Arn
          VectorIndexName: !Sub ${AWS::StackName}-kb-collection
          FieldMapping:
            VectorField: bedrock-knowledge-base-default-vector
            TextField: AMAZON_BEDROCK_TEXT_CHUNK
            MetadataField: AMAZON_BEDROCK_METADATA

  # Bedrock Data Source
  BedrockDataSource:
    Type: AWS::Bedrock::DataSource
    DependsOn: BedrockKnowledgeBase
    Properties:
      Name: !Sub ${AWS::StackName}-agent-kb-datasource
      Description: Data Source for Bedrock AgentCore
      KnowledgeBaseId: !GetAtt BedrockKnowledgeBase.KnowledgeBaseId
      DataSourceConfiguration:
        Type: S3
        S3Configuration:
          BucketArn: !GetAtt S3BucketBKB.Arn

  # Shared Lambda Functions for ITSM operations
  ITSMLambdaFunctionCreate:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-ITSM-Create
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRoleCreate.Arn
      Runtime: nodejs22.x
      Environment:
        Variables:
          TABLE_NAME: !Ref TicketsTable
      CodeUri: functions/create-itsm/
          
  ITSMLambdaFunctionLookup:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-ITSM-Lookup
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRoleLookup.Arn
      Runtime: nodejs22.x
      Environment:
        Variables:
          TABLE_NAME: !Ref TicketsTable
      CodeUri: functions/lookup-itsm/

  LambdaExecutionRoleCreate:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt TicketsTable.Arn
        - PolicyName: !Sub ${AWS::StackName}-APIGatewayInvokePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:Invoke
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:*/*'

  LambdaExecutionRoleLookup:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                Resource: !GetAtt TicketsTable.Arn
        - PolicyName: !Sub ${AWS::StackName}-APIGatewayInvokePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:Invoke
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:*/*'

  # API Gateway
  ApiGatewayITSM:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub ${AWS::StackName}-itsm-api
      Description: Sample ITSM API for AgentCore
      Body:
        openapi: "3.0.1"
        info:
          title: "itsm-api"
          description: "Sample ITSM API for AgentCore"
          version: "2025-05-30T16:52:31Z"
        paths:
          /create:
            post:
              x-amazon-apigateway-auth:
                type: "AWS_IAM"
              responses:
                "200":
                  description: "200 response"
                  content:
                    application/json:
                      schema:
                        $ref: "#/components/schemas/Empty"
              x-amazon-apigateway-integration:
                httpMethod: "POST"
                uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ITSMLambdaFunctionCreate.Arn}/invocations
                responses:
                  default:
                    statusCode: "200"
                requestTemplates:
                  application/json: |
                    #set($inputRoot = $input.path('$'))
                    {
                      "tickettype": "$inputRoot.tickettype",
                      "description": "$inputRoot.description",
                      "impact": "$inputRoot.impact",
                      "urgency": "$inputRoot.urgency"
                    }
                passthroughBehavior: "when_no_match"
                timeoutInMillis: 29000
                contentHandling: "CONVERT_TO_TEXT"
                type: "aws"
            options:
              responses:
                "200":
                  description: "200 response"
                  headers:
                    Access-Control-Allow-Origin:
                      schema:
                        type: "string"
                    Access-Control-Allow-Methods:
                      schema:
                        type: "string"
                    Access-Control-Allow-Headers:
                      schema:
                        type: "string"
                  content:
                    application/json:
                      schema:
                        $ref: "#/components/schemas/Empty"
              x-amazon-apigateway-integration:
                responses:
                  default:
                    statusCode: "200"
                    responseParameters:
                      method.response.header.Access-Control-Allow-Methods: "'DELETE,GET,HEAD,OPTIONS,PATCH,POST,PUT'"
                      method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token'"
                      method.response.header.Access-Control-Allow-Origin: "'*'"
                requestTemplates:
                  application/json: "{\"statusCode\": 200}"
                passthroughBehavior: "when_no_match"
                type: "mock"
          /lookup:
            get:
              x-amazon-apigateway-auth:
                type: "AWS_IAM"
              parameters:
                - name: ticketNumber
                  in: query
                  required: true
                  schema:
                    type: string
              responses:
                "200":
                  description: "200 response"
                  content:
                    application/json:
                      schema:
                        $ref: "#/components/schemas/Empty"
              x-amazon-apigateway-integration:
                httpMethod: "POST"
                uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ITSMLambdaFunctionLookup.Arn}/invocations
                responses:
                  default:
                    statusCode: "200"
                requestTemplates:
                  application/json: |
                    {
                      "ticketNumber": "$input.params('ticketNumber')"
                    }
                passthroughBehavior: "when_no_match"
                timeoutInMillis: 29000
                contentHandling: "CONVERT_TO_TEXT"
                type: "aws"
            options:
              responses:
                "200":
                  description: "200 response"
                  headers:
                    Access-Control-Allow-Origin:
                      schema:
                        type: "string"
                    Access-Control-Allow-Methods:
                      schema:
                        type: "string"
                    Access-Control-Allow-Headers:
                      schema:
                        type: "string"
                  content:
                    application/json:
                      schema:
                        $ref: "#/components/schemas/Empty"
              x-amazon-apigateway-integration:
                responses:
                  default:
                    statusCode: "200"
                    responseParameters:
                      method.response.header.Access-Control-Allow-Methods: "'DELETE,GET,HEAD,OPTIONS,PATCH,POST,PUT'"
                      method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token'"
                      method.response.header.Access-Control-Allow-Origin: "'*'"
                requestTemplates:
                  application/json: "{\"statusCode\": 200}"
                passthroughBehavior: "when_no_match"
                type: "mock"
        components:
          schemas:
            Empty:
              title: "Empty Schema"
              type: "object"

  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: ApiGatewayITSM
    Properties:
      RestApiId: !Ref ApiGatewayITSM
      StageName: prd

  LambdaCreatePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ITSMLambdaFunctionCreate
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayITSM}/*/POST/create
      
  LambdaLookupPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ITSMLambdaFunctionLookup
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayITSM}/*/GET/lookup
  # AgentCore Runtime Resources
  
  # AgentCore Runtime
  BedrockAgentCoreRuntime:
    Type: AWS::BedrockAgentCore::Runtime
    Properties:
      RuntimeName: !Sub ${AWS::StackName}-agentcore-runtime
      Description: AgentCore Runtime for ITSM solution
      ExecutionRoleArn: !GetAtt AgentCoreExecutionRole.Arn
      ContainerConfiguration:
        ImageUri: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/bedrock-agentcore-itsm-agent-repo:latest
        EnvironmentVariables:
          - Name: KNOWLEDGE_BASE_ID
            Value: !GetAtt BedrockKnowledgeBase.KnowledgeBaseId
          - Name: API_GATEWAY_URL
            Value: !Sub https://${ApiGatewayITSM}.execute-api.${AWS::Region}.amazonaws.com/prd
          - Name: AWS_REGION
            Value: !Ref AWS::Region
        MemorySize: 1024
        TimeoutInSeconds: 300
      RuntimeEndpointConfiguration:
        VpcConfiguration:
          SecurityGroupIds: []
          SubnetIds: []
        EndpointType: PUBLIC
      Tags:
        - Key: Application
          Value: ITSM-AgentCore
        - Key: Environment
          Value: Demo
  # IAM Roles and Policies for AgentCore
  
  # AgentCore Execution Role
  AgentCoreExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-AgentCoreExecutionRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AgentCoreRuntimeTrustPolicy
            Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:runtime/*
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-AgentCoreExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Bedrock model access
              - Sid: BedrockModelAccess
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:Retrieve
                  - bedrock:RetrieveAndGenerate
                Resource:
                  - !Sub arn:aws:bedrock:*::foundation-model/*
                  - !Sub arn:aws:bedrock:*:${AWS::AccountId}:inference-profile/*
                  - !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*
              # Knowledge Base access
              - Sid: KnowledgeBaseAccess
                Effect: Allow
                Action:
                  - bedrock:Retrieve
                  - bedrock:RetrieveAndGenerate
                Resource: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/${BedrockKnowledgeBase.KnowledgeBaseId}
              # DynamoDB access for ITSM operations
              - Sid: DynamoDBAccess
                Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: !GetAtt TicketsTable.Arn
              # S3 access for knowledge base
              - Sid: S3Access
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt S3BucketBKB.Arn
                  - !Sub "${S3BucketBKB.Arn}/*"
              # OpenSearch access
              - Sid: OpenSearchAccess
                Effect: Allow
                Action:
                  - aoss:APIAccessAll
                Resource: !GetAtt OpenSearchCollection.Arn
              # API Gateway invoke permissions
              - Sid: APIGatewayInvoke
                Effect: Allow
                Action:
                  - execute-api:Invoke
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayITSM}/*'
              # CloudWatch Logs for monitoring
              - Sid: CloudWatchLogs
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              # ECR access for container images
              - Sid: ECRAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                Resource: '*'
Outputs:
  S3BucketName:
    Description: S3 Bucket for Knowledge Base documents
    Value: !Ref S3BucketBKB
    
  AgentCoreRuntimeId:
    Description: Bedrock AgentCore Runtime ID
    Value: !Ref BedrockAgentCoreRuntime
    Export:
      Name: "ITSMAgentCoreRuntimeId"
    
  AgentCoreRuntimeEndpoint:
    Description: Bedrock AgentCore Runtime Endpoint
    Value: !GetAtt BedrockAgentCoreRuntime.RuntimeEndpoint
    Export:
      Name: "ITSMAgentCoreRuntimeEndpoint"

  KnowledgeBaseId:
    Description: Bedrock Knowledge Base ID
    Value: !GetAtt BedrockKnowledgeBase.KnowledgeBaseId
    
  ApiGatewayUrl:
    Description: API Gateway URL for ITSM operations
    Value: !Sub https://${ApiGatewayITSM}.execute-api.${AWS::Region}.amazonaws.com/prd
    Export:
      Name: "ITSMApiGatewayUrl"